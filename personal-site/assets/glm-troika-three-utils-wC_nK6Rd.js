import{r as e,Y as t,Z as n,_ as r,$ as i}from"./glm-three-CTgrlxYM.js";const a=/\bvoid\s+main\s*\(\s*\)\s*{/g;function o(e){return e.replace(/^[ \t]*#include +<([\w\d./]+)>/gm,(function(e,t){let n=i[t];return n?o(n):e}))}const s=[];for(let g=0;g<256;g++)s[g]=(g<16?"0":"")+g.toString(16);const l=Object.assign||function(){let e=arguments[0];for(let t=1,n=arguments.length;t<n;t++){let n=arguments[t];if(n)for(let t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])}return e},c=Date.now(),u=new WeakMap,f=new Map;let m=1e10;function d(i,a){const g=function(e){const t=JSON.stringify(e,v);let n=_.get(t);null==n&&_.set(t,n=++p);return n}(a);let M=u.get(i);if(M||u.set(i,M=Object.create(null)),M[g])return new M[g];const $=`_onBeforeCompile${g}`,b=function(e,t){i.onBeforeCompile.call(this,e,t);const n=this.customProgramCacheKey()+"|"+e.vertexShader+"|"+e.fragmentShader;let r=f[n];if(!r){const t=function(e,{vertexShader:t,fragmentShader:n},r,i){let{vertexDefs:a,vertexMainIntro:s,vertexMainOutro:l,vertexTransform:c,fragmentDefs:u,fragmentMainIntro:f,fragmentMainOutro:m,fragmentColorTransform:d,customRewriter:v,timeUniform:p}=r;a=a||"",s=s||"",l=l||"",u=u||"",f=f||"",m=m||"",(c||v)&&(t=o(t));(d||v)&&(n=o(n=n.replace(/^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,"\n//!BEGIN_POST_CHUNK $1\n$&\n//!END_POST_CHUNK\n")));if(v){let e=v({vertexShader:t,fragmentShader:n});t=e.vertexShader,n=e.fragmentShader}if(d){let e=[];n=n.replace(/^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,(t=>(e.push(t),""))),m=`${d}\n${e.join("\n")}\n${m}`}if(p){const e=`\nuniform float ${p};\n`;a=e+a,u=e+u}c&&(a=`${a}\nvoid troikaVertexTransform${i}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  ${c}\n}\n`,s=`\ntroika_position_${i} = vec3(position);\ntroika_normal_${i} = vec3(normal);\ntroika_uv_${i} = vec2(uv);\ntroikaVertexTransform${i}(troika_position_${i}, troika_normal_${i}, troika_uv_${i});\n${s}\n`,t=(t=`vec3 troika_position_${i};\nvec3 troika_normal_${i};\nvec2 troika_uv_${i};\n${t}\n`).replace(/\b(position|normal|uv)\b/g,((e,t,n,r)=>/\battribute\s+vec[23]\s+$/.test(r.substr(0,n))?t:`troika_${t}_${i}`)),e.map&&e.map.channel>0||(t=t.replace(/\bMAP_UV\b/g,`troika_uv_${i}`)));return t=h(t,i,a,s,l),n=h(n,i,u,f,m),{vertexShader:t,fragmentShader:n}}(this,e,a,g);r=f[n]=t}e.vertexShader=r.vertexShader,e.fragmentShader=r.fragmentShader,l(e.uniforms,this.uniforms),a.timeUniform&&(e.uniforms[a.timeUniform]={get value(){return Date.now()-c}}),this[$]&&this[$](e)},S=function(){return w(a.chained?i:i.clone())},w=function(e){const t=Object.create(e,x);return Object.defineProperty(t,"baseMaterial",{value:i}),Object.defineProperty(t,"id",{value:m++}),t.uuid=function(){const e=4294967295*Math.random()|0,t=4294967295*Math.random()|0,n=4294967295*Math.random()|0,r=4294967295*Math.random()|0;return(s[255&e]+s[e>>8&255]+s[e>>16&255]+s[e>>24&255]+"-"+s[255&t]+s[t>>8&255]+"-"+s[t>>16&15|64]+s[t>>24&255]+"-"+s[63&n|128]+s[n>>8&255]+"-"+s[n>>16&255]+s[n>>24&255]+s[255&r]+s[r>>8&255]+s[r>>16&255]+s[r>>24&255]).toUpperCase()}(),t.uniforms=l({},e.uniforms,a.uniforms),t.defines=l({},e.defines,a.defines),t.defines[`TROIKA_DERIVED_MATERIAL_${g}`]="",t.extensions=l({},e.extensions,a.extensions),t._listeners=void 0,t},x={constructor:{value:S},isDerivedMaterial:{value:!0},customProgramCacheKey:{writable:!0,configurable:!0,value:function(){return i.customProgramCacheKey()+"|"+g}},onBeforeCompile:{get:()=>b,set(e){this[$]=e}},copy:{writable:!0,configurable:!0,value:function(t){return i.copy.call(this,t),i.isShaderMaterial||i.isDerivedMaterial||(l(this.extensions,t.extensions),l(this.defines,t.defines),l(this.uniforms,e.clone(t.uniforms))),this}},clone:{writable:!0,configurable:!0,value:function(){const e=new i.constructor;return w(e).copy(this)}},getDepthMaterial:{writable:!0,configurable:!0,value:function(){let e=this._depthMaterial;return e||(e=this._depthMaterial=d(i.isDerivedMaterial?i.getDepthMaterial():new t({depthPacking:n}),a),e.defines.IS_DEPTH_MATERIAL="",e.uniforms=this.uniforms),e}},getDistanceMaterial:{writable:!0,configurable:!0,value:function(){let e=this._distanceMaterial;return e||(e=this._distanceMaterial=d(i.isDerivedMaterial?i.getDistanceMaterial():new r,a),e.defines.IS_DISTANCE_MATERIAL="",e.uniforms=this.uniforms),e}},dispose:{writable:!0,configurable:!0,value(){const{_depthMaterial:e,_distanceMaterial:t}=this;e&&e.dispose(),t&&t.dispose(),i.dispose.call(this)}}};return M[g]=S,new S}function h(e,t,n,r,i){return(r||i||n)&&(e=e.replace(a,`\n${n}\nvoid troikaOrigMain${t}() {`),e+=`\nvoid main() {\n  ${r}\n  troikaOrigMain${t}();\n  ${i}\n}`),e}function v(e,t){return"uniforms"===e?void 0:"function"==typeof t?t.toString():t}let p=0;const _=new Map;export{d as c,a as v};
